<html>
<head>
<title>Logical and Procedural Knowledge: Business Rules in Spreadsheets</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body bgcolor="#FFFFFF">
<h1><font color="#000099" face="Arial, Helvetica, sans-serif"> Logical and Procedural Knowledge: <br>
&nbsp;&nbsp;&nbsp;Business Rules in Spreadsheets </font></h1>
<ul>
  <li><a href=#factual_procedural_knowledge>Factual 
    and Procedural Knowledge</a><br>
    <br>
  </li>
  <li><a href=#logical_knowledge>Logical 
    Knowledge</a><br>
    <br>
  </li>
  <li><a href=#traditional_tools>Using Traditional Tools 
    for Logical Knowledge</a><br>
    <br>
  </li>
  <li><a href=#virtual_machines>Virtual 
    Machines for Logical Knowledge</a><br>
    <br>
  </li>
  <li><a href=#different_tools>Different 
    Tools for Different Applications</a></li>
  <ul>
    <li><a href=#spreadsheets>Spreadsheets: Calculation Engines </a></li>
    <li><a href=#knowledgebases>Rule-Based Reasoning Engines</a></li>
    <li><a href=#hybrid_logicbases>Hybrid Rule Engines</a><br>
        <br>
    </li>
  </ul>
  <li><a href=#benefits_features> Benefits of Rules and Reasoning Engines </a></li>
</ul>
<h2><a name="factual_procedural_knowledge"></a><font color="#000066" face="Arial, Helvetica, sans-serif">Factual and Procedural 
  Knowledge</font></h2>
<p>Traditional software tools provide two ways of encoding 
knowledge: one is as <b>facts</b>, or data, in memory; the other is as sequences 
of instructions coded in a <b>procedural</b> manner in  database queries, web scripts or programming languages.</p>
<p>These two types of knowledge, factual and 
procedural, are natural for a computer because a computer is engineered from memory 
(facts/data) and a processing unit that executes a sequence of instructions (procedures). 
It is no accident that database tools and procedural programming languages have 
been with computers since the earliest days. It is no accident that early commercial 
use of computers was called 'data processing.'</p>
<p>Consider an airline reservation 
system. It has factual knowledge about passengers, flights, and bookings stored 
in a database. It has procedures that manipulate that data, for example to book 
a passenger on a flight.</p><p>This type of automation is well suited to a computer's 
design.</p><h2><a name="logical_knowledge"></a><font color="#000066" face="Arial, Helvetica, sans-serif">Logical 
Knowledge</font></h2>
<p>Logical knowledge is <b>relationships</b>. On paper, logical 
knowledge might be expressed as rules, or in tables showing conditions and implied 
results, or as graphs showing connections, or in formats that are particular to 
a given application area. Logical knowledge often mimics human decision making. </p>
<p>In an airline reservation system, pricing knowledge 
would be logical. It is a <b>complex set of rules and tables</b> describing relationships 
between air fare and dates, places, connections, durations, class, frequent flier 
miles, weekends, holidays, discounts, promotions and who knows what else.</p><p>Logical 
knowledge, unless relatively simple, <b>does not lend itself to easy encoding</b> 
in a computer.</p>
<p>It doesn’t fit well in a database, because the relationships 
expressed are more complex than the simple factual relationships databases can 
encode.</p>
<p>It doesn’t fit well in procedural code because the user is 
forced to artificially express the independent logical relationships as a sequence 
of instructions with well-defined flow of control.</p>
<table width="85%" border="1" cellpadding="10" bgcolor="#EBFFFF" align="center" bordercolor="#000080" cellspacing="2"> 
<tr> <td> <h3 align="center"><font color="#000080">Examples of Logical Knowledge</font></h3><p><b><i>Pricing</i></b> 
&#151; the relationships between price and the factors affecting it, for almost 
any product of even modest complexity;</p><p><b><i>Regulations</i></b> &#151; 
government’s and private organization’s rules and regulations, such as tax codes, 
insurance rules, legal requirements, benefits, purchasing, and work flow;</p><p><b><i>Configuration</i></b> 
&#151; the complex relationships between customer needs and products and components;</p><p><b><i>Support</i></b> 
&#151; the relationships between faults and symptoms in diagnostic technical support 
solutions, or between customer needs, and appropriate products and services;</p><p><b><i>Scheduling</i></b> 
&#151; the rules governing broadcast scheduling, radio and TV music scheduling, 
work scheduling, resource allocation, sports events;</p><p><b><i>Grammars</i></b> 
&#151; translation rules between data transfer protocols, program inputs, or natural 
languages;</p><p><b><i>Scientific</i></b> &#151; geologic relationships between 
surface observations and oil below, electric circuit behavior, network modeling, 
medical diagnosis, and economic modeling.</p></td></tr> </table><h2><a name="traditional_tools"></a><font color="#000066" face="Arial, Helvetica, sans-serif">Using Traditional Tools 
for Logical Knowledge</font></h2>
<p><img src="overview_traditional.gif" width="330" height="220" align="right" border="0">While 
not well suited for the task, traditional tools are often used to encode logical 
knowledge.</p>
<p>In a few cases, the traditional tools are workable. For example, 
if the relationships are simple enough to be expressed in tables with the same 
columns, then a  database can be used effectively. If the rules fit readily in 
a decision tree, then that tree can be represented by procedural branching statements.</p>
<p>But 
logical knowledge of any significance has a <b>variety of factors</b> in the relationships, 
making them ill-suited for database; and no implied sequence of execution, making 
them awkward to code procedurally. Different combinations of rules in different 
sequences are required depending on the input data.</p>
<p>The <b>advantage</b> 
of using traditional tools is, well, that they are traditional tools. There are 
a large number of users who are skilled in using them.</p>
<p>The <b>disadvantage</b> 
of using traditional tools is the procedural code and/or fragmented collections 
of data tables needed to express the interrelated logical relationships winds 
up being a rat’s nest of unwieldy, difficult to maintain and highly error prone 
code.</p><p>For some application areas, this might not be a factor. But if the 
logical knowledge is changing, and it is important to keep up with the changes, 
then the <b>costs of maintaining </b>the encoding of the logical knowledge becomes 
prohibitive.<span style="mso-spacerun: yes">  </span>More importantly, due to 
the time consuming and error prone nature of that approach, competitive advantage 
could well be lost.</p><table width="85%" border="1" cellpadding="10" cellspacing="2" align="center" bgcolor="#EBFFFF" bordercolor="#000080"> 
<tr valign="top"> <td> <h3><font color="#000080">There’s If-Then and 
then there’s If-Then</font></h3>
<p class=MsoNormal>The term ‘if-then’ for rules 
is sometimes confusing because it is used both to describe branching instructions 
in a procedure, and certain logical relationships. In spreadsheets and procedural code, IF() functions and if-then 
statements steer the flow of control. As logical relationships, if-then rules 
have no implied order of execution.</p></td></tr> 
</table>
<h2><a name="virtual_machines"></a><font color="#000066" face="Arial, Helvetica, sans-serif">Virtual<span style="mso-spacerun: yes">  
</span>Machines for Logical Knowledge</font></h2>
<p><img src="overview_reasoning_engine.gif" width="350" height="300" border="0" align="right">If 
the problem with encoding logical knowledge is the underlying machine, then what’s 
needed to do the job right is a machine designed to handle logical knowledge. 
Building a hardware machine is not very practical, but software can be used to 
build a wide variety of <b>virtual machines</b>.</p>
<p>This is exactly what is 
done in all of the tools available for business rule systems, 
expert systems, knowledge base systems, logicbase systems, case-base systems and others.</p>
<p>Each 
of these tools has a virtual machine architecture with two key components:</p><ul> 
<li>a “<b>knowledge representation</b>” syntax and interface for entering and 
maintaining logical relationships in a file called a “<b>knowledge base</b>,” 
and</li><li>a “<b>reasoning engine</b>” that takes input data and, using the knowledge 
base, produces answers.</li></ul><p>For example:</p><ul> <li>A pricing application 
has a knowledge base of pricing rules and regulations; takes as input particulars 
of a given flight; and produces as output a fare.</li><li>A support application 
has a knowledge base of diagnostic rules; takes as input symptoms of a given problem; 
and produces as output a solution.</li><li>A configuration application has a knowledge 
base of related components; takes as input customer requirements; and produces 
as output a configured assembly.</li></ul>
<p>This architecture provides the major 
benefit that the logical knowledge no longer has to be forced into a format that 
is ill-served for coding it. Because the logical knowledge is more <b>naturally 
expressed</b> in a knowledge representation language (e.g. business rules), it is <b>easier to create 
and maintain</b>. Because it is easier to maintain, it is less error-prone, more 
reliable, and changes can be incorporated in production software much more rapidly.</p>
<p>In 
some cases the logical relationships can be maintained directly by those with the 
knowledge, avoiding the translation step through an intermediate programmer. This 
further magnifies the benefits.</p>
<table width="75%" border="1" cellpadding="10" bgcolor="#EBFFFF" align="center" bordercolor="#000080" cellspacing="2"> 
<tr> <td> <h3 align="center"><font color="#000080" face="Arial, Helvetica, sans-serif">Artificial Intelligence</font></h3>
<p class=MsoNormal>The 
science of Artificial Intelligence (AI) concerns itself with the engineering and 
use of virtual machines that work with knowledge that cannot be easily expressed 
either factually or procedurally. Working with logical knowledge is a large part 
of AI. The term AI might be somewhat justified considering that human brains, 
unlike computers, are naturally good at processing logical relationships. </p></td></tr> 
</table><h2><a name="different_tools"></a><font color="#000066" face="Arial, Helvetica, sans-serif">Different 
Tools for Different Applications</font></h2>
<p>Unfortunately, there is tremendous 
variety in the forms of logical knowledge required for different application domains, 
and accordingly, there are a number of different tools and approaches.</p><p><b>How 
well a given tool fits a particular application depends on how close the knowledge 
representation language and reasoning engine match the way the application logic 
is naturally expressed and used.</b></p>
<p>For example, pricing knowledge is usually 
formal and precise, whereas knowledge about technical support has more vagaries 
in it, and also requires support for natural language questions and answers.<span style="mso-spacerun:
yes">  </span>Configuration knowledge includes rules for how components are combined 
and also needs to express the logical relationships of hierarchies of parts.</p>
<p>Both 
pricing and technical support would have reasoning engines intent on finding a 
specific solution, but the knowledge for configuring complex products needs to 
be applied in a building block manner, creating a complex structure as output.</p><p>There 
are numerous <b>general-purpose tools</b> that might fit a given application, 
or an organization might decide to build a customized tool for their particular 
application.</p><p>A <b>customized tool</b> has the  benefit that the knowledge 
representation can be designed to specifically match the way knowledge for that 
application is expressed. This often means those with the knowledge can directly 
maintain the knowledge base without programmer intervention.</p>
<p>A general-purpose 
tool can be purchased off-the-shelf and might provide a good enough fit for the 
application.</p>
<h3><a name="spreadsheets"></a><font color="#000066" face="Arial, Helvetica, sans-serif">Spreadsheets: Calculation Engines</font> </h3>
<p>Spreadsheets are a perfect example of a specialized tool for a specific 
type of  knowledge. In this case the logical relationships are arithmetic 
formulas linking the contents of the various cells.</p>
<p>The designers of a spreadsheet 
program first create the pattern of cells and allowable formulas users can use 
to express relationships.<span style="mso-spacerun:
yes">  </span>That is the knowledge representation.</p>
<p>They then write a program 
that knows how to compute the required cells in a spreadsheet. That is the reasoning 
engine. The reasoning engine determines in what order the cells are calculated, and also computes a value for each of the cell formulas and contents. </p>
<p>The  relationships defined in the spreadsheet, such as this 
cell is equal to the sum of those cells, are then used to compute values for different 
inputs. The result is financial users can directly enter the types of relationships 
they deal with in a familiar manner, without requiring a programmer. The underlying 
spreadsheet engine does the computation for them.</p>
<p>As we all know, spreadsheets 
are tremendously popular because they let non-programmers encode  relationships 
that are executed by the spreadsheet calculation engine. Of course, they are limited 
to expressing the sorts of things you can express in an array of related cells 
and formulae.</p>
<h3><a name="knowledgebases"></a><font color="#000066" face="Arial, Helvetica, sans-serif">Rule-Based Reasoning Engines</font></h3>
<p><img src="overview_logicbase.gif" width="330" height="180" align="right" border="0">There 
are many general purpose business rule and expert system products that follow 
the same architecture. They provide a knowledge representation for entering logical 
relationships as rules, and a reasoning engine that knows how to execute those 
rules.</p>
<p>These tools are powerful and are often used to solve the problem 
of encoding logical relationships.</p>
<p>The degree to which they are successful 
is related to how <b>close the semantics of the particular logical relationships 
are to the given tool</b>. When the tool does not fit particularly well, then often, 
programmers are still needed to code the logical relationships for the tool. This 
means those with the know-how do not maintain the logicbase directly.<span style="mso-spacerun: yes">  
</span>On the other hand, this is a better solution than using traditional tools 
because the programmer is now working with declarative specifications of the logical 
relationships rather than forcing them into difficult to write and maintain procedural code.</p>
<p>One way to enhance the fit between a   reasoning engine  and the logical relationships is to offer a <b>multi-layered approach for writing rules and decision tables</b>. This allows those with the know-how to write and test many, if not all, of their rules. The result 
is quicker initial development and faster, more reliable response to changing conditions.</p>
<h3><a name="hybrid_logicbases"></a><font color="#000066" face="Arial, Helvetica, sans-serif">Hybrid Rule Engines</font></h3>
<p>Hybrid rule engines <b>combine procedural and logical knowledge</b> together in one software tool. This lets users apply  procedural knowledge to those parts of the application that are procedural in nature, and logical knowledge to those parts that better modeled with rules or logical relationships. </p>
<p><a href="http://www.arulesxl.com">ARulesXL</a>&#8482; is a rule-based engine, based on logic, that is integrated with Excel&#8482;. It 
  is a powerful concept, combining the calculation engine of a spreadsheet with 
the reasoning engine of a business rules logicbase.</p>
<p>ARulesXL has a knowledge representation language that allows the rules to be written in a very 
  easy to read and understand syntax, in text and decision table formats. One large accounting firm found it was possible 
  to have meetings with people from various disciplines such as, tax, accounting, 
  and law work together on an equity compensation package where all could read 
  and understand the rules being used. This makes it possible for the person with the know-how in an organization to <b>express their knowledge directly</b> on a spreadsheet where the <b>rules can be seen and experimented with</b>.</p>
<p>Knowledge representation in ARulesXL uses a <b>layered approach</b>. This simplist level is decision tables, which specify conditions and values in a row and column format. The next level is general-purpose pattern-matching rules. The advanced level is pure logic which can be used to express the most complex and intertwined logical relationships. </p>
<p>Since procedural and logical knowledge are used to model separate parts of an application, the ARulesXL reasoning engine can run in conjunction with a variety of Web-based and PC-based application environments. This allows rules to be created and maintained in Excel, but then <b>deployed to users over the Web or as part of any other software tool</b>. </p>
<h2><a name="benefits_features"></a><font color="#000066" face="Arial, Helvetica, sans-serif">Benefits of Rules and Reasoning Engines</font> </h2>
<p>These 
are the primary benefits of using reasoning engines to build and deploy logical knowledge.</p>
<ul> <li><b>Automate 
'Difficult' Components</b> &#151; Rules and reasoning engines can easily implement application components 
that are 'difficult' using conventional tools. Typically they are difficult because 
they are specified as sets of interrelated rules and relations that are too complex 
for database, yet are not easily expressed in procedural languages. Because a 
logicbase is composed of non-procedural logical relations and rules, this type 
of application is very easy in ARulesXL, and oftentimes can be expressed in a fraction of the code needed in procedural tools and languages.</li>
  <li><b>Bring Business Rules to Those Who Know Them Best</b> &#151; Rules and reasoning engines can often be maintained directly by the persons with the expertise or know-how. This is  due to the declarative nature of rules, and  
to the ease with which rules can represent various types of knowledge. </li>
  <li><b>Greater 
Reliability</b> &#151; Rules  can be independently tested and debugged,  making for quicker, more error-free implementation. Also because rules are a more concise way of encoding knowledge,  there is simply less code to go wrong. </li>
  <li><b>Rapid Development</b> &#151; Rule sets are developed 
in a fraction of the time required using procedural languages and database. Users 
don't worry about procedural flow-of-control, concentrating 
instead on pure application logic. </li>
  <li><b>Easy Integration </b>&#151; Rule sets can be deployed as part of any application context.  ARulesXL  provides interfaces for popular tools and programming environments. </li><li><b>International Applications</b> &#151; Logicbases can be deployed 
in any national language.</li>
</ul>
<p><span class="footer"><font size="-1">Copyright &copy; 2005-7 Amzi! inc. 
      Amzi! is a registered trademark and ARulesXL is a trademark of Amzi! 
      inc. <br />
Microsoft and Excel  are trademarks or registered trademarks of Microsoft Corporation in the United States and/or other countries. </font></span></p>
</body>

</html>
